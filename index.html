<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="V-Lab.....Search Algorithms....Linear Search and Binary Search">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A* PathFinding</title>
    <link rel="icon" href="images/vlab-logo.png" type="image/x-icon">
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/base16/harmonic16-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.8/clipboard.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>

</head>

<body>
    <header class="header">
        <div class="logo">
            <a href="https://www.vlab.andcollege.du.ac.in" rel="noopener" target="_blank">
                <img class="logo-img" src="images/logo.png"  alt="VLab">
            </a>
        </div>
        <div class="vlabtitle">
            <h1 class="">V-LAB @ ANDC</h1>
        </div>
        <div class="menu-toggle" onclick="toggleMenu()">☰</div>
        <nav class="nav-menu" id="small-screen">
            <div class="close-btn" onclick="toggleMenu()">✖</div>
            <a href="https://www.vlab.andcollege.du.ac.in">Home</a>
            <a href="https://www.vlab.andcollege.du.ac.in#labs_section">Labs</a>
            <a href="https://www.vlab.andcollege.du.ac.in#team">Team</a>
            <a href="https://www.andcollege.du.ac.in">College Website</a>
        </nav>

    </header>

    <div class="h1title">
        <h1>A*  PathFinding</h1>
    </div>

    <div class="pageview">
        <nav class="navigation">
            <button class="link" onclick="switchContent('aim')">
                <img class="icon" src="images/Aim_img.png"  alt="Aim">
                <span>Aim</span>
            </button>

            <button class="link" onclick="switchContent('theory')">
                <img class="icon" src="images/theory_img.png"  alt="THEORY">
                <span>Theory</span>
            </button>

            <button class="link" onclick="switchContent('procedure')">
                <img class="icon" src="images/procedure_img.png" alt="PROCEDURE">
                <span>Procedure</span>
            </button>

            <button class="link" onclick="switchContent('practice')">
                <img class="icon" src="images/practice_img.png"  alt="PRACTICE">
                <span>Practice</span>
            </button>

            <button class="link" onclick="switchContent('code')">
                <img class="icon" src="images/code_img.png"  alt="CODES">
                <span>Codes</span>
            </button>

            <button class="link" onclick="switchContent('result')">
                <img class="icon" src="images/result_img.png"  alt="RESULT">
                <span>Result</span>
            </button>

            <button class="link" onclick="switchContent('quiz')">
                <img class="icon" src="images/quiz_img.png" alt="QUIZ">
                <span>Quiz</span>
            </button>

            <button class="link" onclick="switchContent('references')">
                <img class="icon" src="images/reference_img.png"  alt="REFERENCE">
                <span>References</span>
            </button>
            <button class="link" onclick="switchContent('tnt')">
                <img class="icon" src="images/tnt_img.png"  alt="TEAM & TOOLS">
                <span>Team & Tools</span>
            </button>

        </nav>


        <section class="practical">
            <div class="container" id="aim">
                <div class="title">
                    Aim
                </div>
                <div class="content">
                    <p>
                        The aim of this Virtual Lab is to implement the A* pathfinding algorithm that dynamically finds the shortest path between two points , combining heuristic and cost-based approaches to efficiently navigate through a weighted graph, similar to real-world navigation systems.
                    </p>
                </div>

            </div>
            <div class="container" id="theory">
                <div class="title">
                    Theory
                </div>
                <div class="content">
                    <p>
                        The A* pathfinding algorithm is a widely used search algorithm that combines the strengths of Dijkstra's algorithm and Greedy Best-First Search. It leverages a heuristic function to estimate the cost from a given node to the goal, in addition to the actual cost from the start node to the current node. This combination allows A* to prioritize paths that are most likely to lead to the shortest (or lowest cost) solution.  This blend of cost-based and heuristic-driven exploration makes A* highly efficient in navigating complex graphs and finding optimal paths.
                    </p>
            
                    <p>
                        Pathfinding algorithms, such as A*, are fundamental concepts in computer science with diverse real-world applications:
                    </p>
            
                    <ul class="stepsP">
                        <li><strong>Navigation Systems:</strong> A* is commonly used in GPS navigation systems and online mapping services to calculate the shortest or fastest routes between locations, considering factors like distance, traffic, and road closures.</li>
                        <li><strong>Game Development:</strong> A* is crucial in game AI, enabling characters or objects to find optimal paths through complex game levels or environments.  It's used for enemy movement, character navigation, and resource gathering.</li>
                        <li><strong>Robotics:</strong> Robots use A* to navigate physical spaces, plan collision-free paths, and reach target destinations, even in dynamic environments with obstacles.</li>
                        <li><strong>Network Routing:</strong> A* is employed in network protocols to find the shortest or most efficient data transmission paths across networks, optimizing for latency and bandwidth.</li>
                        <li><strong>Logistics and Supply Chain:</strong> A* helps optimize delivery routes, warehouse operations, and supply chain management by finding the most cost-effective paths for vehicles and goods.</li>
                        <li><strong>Urban Planning:</strong> A* assists in planning efficient transportation networks, designing optimal routes for public transportation, and managing traffic flow in urban environments.</li>
                        <li><strong>Autonomous Vehicles:</strong> Self-driving cars rely on pathfinding algorithms like A* to navigate roads, plan routes, and make real-time decisions while adhering to traffic rules and avoiding obstacles.</li>
                    </ul>
            
                </div>
            </div>
            <!-- Procedure Section -->
            <div class="container" id="procedure">
                <div class="title">
                    Procedure
                </div>
                <div class="content">
                    <p>The procedure for implementing the A* pathfinding algorithm is as follows:</p>
                    <ol class="steps-list">
                        <li><strong>Input:</strong> The graph representation (nodes, edges with weights), start node, and goal node.</li>
                        <li><strong>Initialization:</strong> Create the following data structures:
                            <ol type="i">
                                <li><strong>Priority Queue (Open Set):</strong> Stores nodes, prioritized by their estimated total cost (f = g + h). Initially, contains only the start node.</li>
                                <li><strong>g-Score (Cost from Start):</strong> A dictionary to track the actual cost (g) of reaching each node from the start node. Initialize g(start) = 0.</li>
                                <li><strong>Heuristic Function (h):</strong> Estimates the cost from any node to the goal.  Must be defined for all nodes.</li>
                                <li><strong>Came From (Parent Nodes):</strong> A dictionary to keep track of the parent node for each node, used for path reconstruction.</li>
                                <li><strong>Closed Set:</strong> A set to keep track of nodes already evaluated. Initially empty.</li>
                            </ol>
                        </li>
                        <li><strong>Start Node Initialization:</strong>
                            <ul>
                                <li>Set g(start) = 0.</li>
                                <li>Calculate f(start) = g(start) + h(start).</li>
                                <li>Add the start node to the priority queue (Open Set).</li>
                            </ul>
                        </li>
                        <li><strong>Main Loop (while Open Set is not empty):</strong>
                            <ol type="i">
                                <li><strong>Current Node Selection:</strong> Dequeue the node with the lowest f-value from the priority queue (Open Set). This is the current node.</li>
                                <li><strong>Goal Check:</strong> If the current node is the goal node, the search is complete. Reconstruct the path by backtracking through the "Came From" dictionary.</li>
                                <li><strong>Move Current Node to Closed Set:</strong> Add the current node to the Closed Set.</li>
                                <li><strong>Neighbor Exploration:</strong> For each neighbor of the current node:
                                    <ol type="a">
                                        <li><strong>Tentative g-Score Calculation:</strong> Calculate the tentative g-value for the neighbor:  <i>tentative_g = g(current) + cost(current, neighbor)</i>.</li>
                                        <li><strong>Neighbor Evaluation:</strong>
                                            <ol type="1">
                                                <li><strong>Shorter Path Found OR Neighbor Not Visited:</strong> If <i>tentative_g < g(neighbor)</i> OR <i>neighbor</i> is not in the Open Set or Closed Set:
                                                    <ul>
                                                        <li>Update g(neighbor) = <i>tentative_g</i>.</li>
                                                        <li>Calculate f(neighbor) = g(neighbor) + h(neighbor).</li>
                                                        <li>Set <i>Came From(neighbor) = current</i>.</li>
                                                        <li>If <i>neighbor</i> is not in the Open Set, add it to the Open Set.</li>
                                                    </ul>
                                                </li>
                                                <li><strong>Duplicate in Open Set with Higher Cost:</strong> If <i>neighbor</i> is already in the Open Set but the new <i>f(neighbor)</i> is lower, update the <i>f(neighbor)</i> in the Open Set. (This might require re-sorting the priority queue depending on implementation).</li>
                                            </ol>
                                        </li>
                                    </ol>
                                </li>
                            </ol>
                        </li>
                        <li><strong>No Path Found:</strong> If the Open Set becomes empty and the goal node has not been reached, there is no path.</li>
                        <li><strong>Output:</strong> The reconstructed shortest path (if found) and its total cost.</li>
                    </ol>
                </div>
            </div>

            <div class="container" id="code">
                <div class="title">Code</div>
                <p>Example program</p>
            
                <div class="code-blocks">
                    <!-- Python code block -->
                    <div id="pyCode" class="code-block active" style="display: block;">
                        <div class="code-content">
                            <pre><code class="language-python">
# Python
# Installation:
# - Ensure pygame is installed.
# - Run: pip install pygame

# How to Use:
# 1. First, select the Source and Destination nodes on the grid using the left mouse click.
#    - Source Node: Orange
#    - Destination Node: Cyan
# 2. Add walls to the grid by left-clicking on other cells.
# 3. Remove walls or nodes by right-clicking.
# 4. Press the Spacebar to start the A* search after setting the source and destination.
# 5. To refresh the grid, press the "C" key.

# Additional Notes:
# - The grid is represented visually.
# - Walls act as barriers that the pathfinding algorithm cannot traverse.


import pygame
import math
from queue import PriorityQueue

WIDTH=800
WIN=pygame.display.set_mode((WIDTH,WIDTH))
pygame.display.set_caption("A* Path finding")

RED = (255,0,0)
GREEN = (0,255,0)
BLUE = (0,0,255)
YELLOW = (255,255,0)
WHITE = (255,255,255)
BLACK = (0,0,0)
PURPLE = (128,0,128)
ORANGE = (255,165,0)
GREY = (128,128,128)
TURQUOISE = (64,224,208)

class Spot:  #NODE CLASS
    def __init__(self,row,col,width,total_rows):
        self.row=row
        self.col=col
        self.x=row*width
        self.y=col*width
        self.color=WHITE
        self.neighbors=[]
        self.width=width
        self.total_rows=total_rows

    def get_pos(self):
        return self.row,self.col

    def is_closed(self):
        return self.color==RED

    def is_open(self):
        return self.color==GREEN
    
    def is_barrier(self):
        return self.color==BLACK
    
    def is_start(self):
        return self.color==ORANGE

    def is_end(self):
        return self.color==TURQUOISE

    def reset(self):
        self.color=WHITE

    def make_start(self):
        self.color=ORANGE

    def make_close(self):
        self.color =RED

    def make_open(self):
        self.color=GREEN

    def make_barrier(self):
        self.color=BLACK

    def make_end(self):
        self.color=TURQUOISE

    def make_path(self):
        self.color=PURPLE

    def draw(self ,win):
        pygame.draw.rect(win,self.color,(self.x ,self.y ,self.width,self.width))

# Try adding diagonal movements
    def update_neighbors(self,grid):
        self.neighbors=[]
        if self.row< self.total_rows-1 and not grid[self.row+1][self.col].is_barrier(): #DOWN
            self.neighbors.append(grid[self.row+1][self.col])

        if self.row>0 and not grid[self.row-1][self.col].is_barrier(): #UP
            self.neighbors.append(grid[self.row-1][self.col])

        if self.col< self.total_rows-1 and not grid[self.row][self.col+1].is_barrier(): #RIGHT
            self.neighbors.append(grid[self.row][self.col+1])

        if self.col>0 and not grid[self.row][self.col-1].is_barrier(): #LEFT
            self.neighbors.append(grid[self.row][self.col-1])

    def __lt__(self,other):
        return False

def h(p1,p2):
    x1,y1=p1
    x2,y2=p2
    return (abs(x1-x2)+abs(y1-y2))  # Try euclidean distance if implementing diagonal movements too
def reconstruct_path(came_from,current,draw):
    while current in came_from:
        current=came_from[current]
        current.make_path()
        draw()

def algorithm(draw,grid,start,end):
    count=0
    open_set=PriorityQueue()
    open_set.put((0,count,start))
    came_from={}
    g_score={spot:float("inf")for row in grid for spot in row}
    g_score[start]=0
    f_score={spot:float("inf")for row in grid for spot in row}
    f_score[start]=h(start.get_pos(),end.get_pos())

    open_set_hash={start}

    while not open_set.empty():
        for event in pygame.event.get():
            if event.type==pygame.QUIT:
            pygame.quit()
        current =open_set.get()[2]
        open_set_hash.remove(current)

        if current ==end:
            reconstruct_path(came_from,end,draw)
            end.make_end()
            start.make_start()
            return True

        for neighbor in current.neighbors:
            temp_g_score=g_score[current]+1

            if temp_g_score< g_score[neighbor]:
            came_from[neighbor]=current
            g_score[neighbor]=temp_g_score
            f_score[neighbor]=temp_g_score+h(neighbor.get_pos(),end.get_pos())
            if neighbor not in open_set_hash:
                count+=1
                open_set.put((f_score[neighbor],count,neighbor))
                open_set_hash.add(neighbor)
                neighbor.make_open()
        draw()

        if current!=start:
            current.make_close()

    return False


def make_grid(rows,width):
    grid=[]
    gap=width//rows
    for i in range(rows):
        grid.append([])
        for j in range(rows):
            spot=Spot(i,j,gap,rows)
            grid[i].append(spot)
    return grid

def draw_grid(win,rows,width):
    GAP=width//rows
    for i in range(rows):
        pygame.draw.line(win,GREY,(0,i*GAP),(width,i*GAP))
        for j in range(rows):
            pygame.draw.line(win,GREY,(j*GAP,0),(j*GAP,width))

def draw(win,grid,rows,width):
    win.fill(WHITE)

    for row in grid:
        for spot in row:
            spot.draw(win)

    draw_grid(win,rows,width)
    pygame.display.update()


def get_clicked_pos(pos,rows,width):
    gap=width//rows
    y,x=pos

    row=y//gap
    col=x//gap
    return row,col

def main(win,width):
    ROWS=50
    grid=make_grid(ROWS,width)

    start=None
    end=None

    run=True
    

    while run:
        draw(win,grid,ROWS,width)
        for event in pygame.event.get():
            if event.type==pygame.QUIT:
            run=False
            if pygame.mouse.get_pressed()[0]: #left
            pos=pygame.mouse.get_pos()
            row,col=get_clicked_pos(pos,ROWS,width)
            spot= grid[row][col]
            if not start and spot!=end:
                start=spot
                start.make_start()
            elif not end and spot!=start:
                end=spot
                end.make_end()
            elif spot !=end and spot !=start:
                spot.make_barrier()
            elif pygame.mouse.get_pressed()[2]: #right
            pos=pygame.mouse.get_pos()
            row,col=get_clicked_pos(pos,ROWS,width)
            spot= grid[row][col]
            spot.reset()
            if spot==start:
                start=None
            elif spot==end:
                end=None
            if event.type==pygame.KEYDOWN:
            if event.key==pygame.K_SPACE and  start and end:
                for row in grid:
                    for spot in row:
                        spot.update_neighbors(grid)
                algorithm(lambda:draw(win,grid,ROWS,width),grid,start,end)
            if event.key==pygame.K_c:
                start=None
                end=None
                grid=make_grid(ROWS,width)

    pygame.quit()


if __name__=='__main__':
    main(WIN,WIDTH)
                                
                                
                            </code></pre>
                            <button class="copy-button" onclick="copyCode('pyCode')">Copy</button>
                        </div>
                    </div>
                </div>
            </div>            

    <div id="practice">
               
          
  
    <style>
        h2, h3, h4 { color: #333; margin-bottom: 10px; }
        p, ul { margin-bottom: 20px; }
        ul { list-style-type: disc; padding-left: 20px; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; background: #fff; }
        th, td { border: 1px solid #ddd; padding: 12px; text-align: center; }
        th { background-color: #007bff; color: #fff; }
        tr:nth-child(even) { background-color: #f2f2f2; }
        tr:hover { background-color: #eaf4ff; }
       
    </style>
<!-- PRACTICE SECTION-->

    <div class="container">
     
            <h2>Graph and Heuristics</h2>
            <div class="image-container">
                <img src="images/1.png" alt="Graph Representation of Nodes and Edges">
            </div>
            <p class="heuristics">Heuristics (h values):</p>
            <ul class="heuristics">
                <li>h(A) = 10</li>
                <li>h(B) = 4</li>
                <li>h(C) = 2</li>
                <li>h(D) = 0</li>
            </ul>
        <h2>Understanding the Components</h2>
        <p><strong>f(n) = g(n) + h(n)</strong>: The total estimated cost of the path through node 'n'.</p>
        <ul>
            <li><strong>g(n)</strong>: The actual cost of the path from the start node to node 'n'.</li>
            <li><strong>h(n)</strong>: The estimated cost from node 'n' to the goal node (heuristic).</li>
        </ul>
        <p><strong>Priority Queue</strong>: A queue where items are prioritized based on their f(n) value (lowest f(n) gets the highest priority).</p>
        
        <h2>Initialization</h2>
        <table>
            <tr>
                <th>Node</th><th>f(n)</th><th>g(n)</th><th>h(n)</th><th>Came From</th>
            </tr>
            <tr>
                <td>A</td><td>10</td><td>0</td><td>10</td><td>-</td>
            </tr>
        </table>
        
        <div class="priority-queue">Priority Queue (Iteration 1): Open Set = {(A, 10)}; Closed Set = {}</div>
        
        <div class="step">
            <h3>Iteration 1: Expand A</h3>
            <p>Successors of A: B, C</p>
            <ul>
                <li>For B: g(B) = 10, h(B) = 4, f(B) = 14</li>
                <li>For C: g(C) = 5, h(C) = 2, f(C) = 7</li>
            </ul>
            <h4>Updated Table:</h4>
            <table>
                <tr><th>Node</th><th>f(n)</th><th>g(n)</th><th>h(n)</th><th>Came From</th></tr>
                <tr><td>A</td><td>10</td><td>0</td><td>10</td><td>-</td></tr>
                <tr><td>B</td><td>14</td><td>10</td><td>4</td><td>A</td></tr>
                <tr><td>C</td><td>7</td><td>5</td><td>2</td><td>A</td></tr>
            </table>
            <div class="priority-queue">Priority Queue (Iteration 2): Open Set = {(C, 7), (B, 14)}; Closed Set = {A}</div>
        </div>
        
        <div class="step">
            <h3>Iteration 2: Expand C</h3>
            <p>Successors of C: D, B</p>  <ul>
                <li>For D: g(D) = g(C) + cost(C, D) = 5 + 15 = 20; h(D) = 0; f(D) = 20</li>
                <li>For B: g(B) = g(C) + cost(C, B) = 5 + 6 = 11; h(B) = 4; f(B) = 15  <p><strong><br> Check if this is shorter than the current g(B):</br></strong></p>
                    <p>Current g(B) = 10 (from A to B directly)</p>
                    <p>New g(B) = 11 (through C)</p>
                    <p><strong>Since 11 is greater than 10, we DO NOT put (B,15) in the open set.</strong></p>
                </li>
            </ul>
            <h4>Updated Table:</h4>
            <table>
                <tr><th>Node</th><th>f(n)</th><th>g(n)</th><th>h(n)</th><th>Came From</th></tr>
                <tr><td>A</td><td>10</td><td>0</td><td>10</td><td>-</td></tr>
                <tr><td>B</td><td>14</td><td>10</td><td>4</td><td>A</td></tr> <tr><td>C</td><td>7</td><td>5</td><td>2</td><td>A</td></tr>
                <tr><td>D</td><td>20</td><td>20</td><td>0</td><td>C</td></tr>
            </table>
            <div class="priority-queue">Priority Queue (Iteration 3): Open Set = {(B, 14), (D, 20)}; Closed Set = {A, C}</div>
        </div>
        
        <div class="step">
            <h3>Iteration 3: Expand B</h3>
            <p>Successor of B: D</p>
            <ul>
                <li>For D: g(D) = 14, h(D) = 0, f(D) = 14</li>
            </ul>
            <h4>Updated Table:</h4>
            <table>
                <tr><th>Node</th><th>f(n)</th><th>g(n)</th><th>h(n)</th><th>Came From</th></tr>
                <tr><td>A</td><td>10</td><td>0</td><td>10</td><td>-</td></tr>
                <tr><td>B</td><td>14</td><td>10</td><td>4</td><td>A</td></tr>
                <tr><td>C</td><td>7</td><td>5</td><td>2</td><td>A</td></tr>
                <tr><td>D</td><td>14</td><td>14</td><td>0</td><td>B</td></tr>
            </table>
            <div class="priority-queue">Priority Queue (Iteration 4): Open Set = {(D, 14), (D, 20)}; Closed Set = {A, C, B}</div>
        </div>
        
        <div class="step">
            <h3>Iteration 4: Expand D</h3>
            <p><strong>D is the goal. We're done!</strong></p>
            <div class="optimal">
                <p>Optimal Path: <strong>A → B → D</strong></p>
                <p>Optimal Cost: <strong>14</strong></p>
            </div>
        </div>
    </div>         
       
<!--###################################################################################################################-->

<div class="container" id="practice2">
    <h2>Graph Based Implementation</h2>
    <canvas id="graphCanvas"></canvas>
<div class="controls">
    <button id="next">Next Step</button>
    <button id="back">Back Step</button>
    <button id="reset">Reset</button>
</div>
<div id="open-closed-display" style="margin-bottom: 10px; font-weight: bold;"></div>
<div id="narration-display" style="margin-bottom: 10px; font-weight: bold;"></div>
<table id="info-table">
    <thead>
        <tr>
            <th>Node</th>
            <th>G</th>
            <th>H</th>
            <th>F</th>
            <th>From</th>
        </tr>
    </thead>
    <tbody></tbody>
</table>
</div>  

<!--###################################################################################################################-->

<div class="container" id="practice1">
    <div class="title">
        <h2>Grid Based Implementation</h2>
    </div>

    <!-- Grid Diagram -->
    <div id="grid"></div>
    <div class="information">
        <h4>You can click the blocks to change them into walls and create a maze.</h4>
    </div>
    <!-- Execution Box -->
    <div id="executionBox">
        <h3>Execution Step:</h3>
        <p id="stepDetails">Click 'Next Step' to begin.</p>
    </div>

    <!-- Next Step Button -->
    <button class="sbt" id="nextStep">Next Step</button>
    <div class="information">
        <h4>Works best on bigger screens.</h4>
    </div>
</div>         
<!--###################################################################################################################-->
<div class="container" id="practice2">
    <div class="title">
        <h2>Map implementation example</h2>
    </div>
        <!-- Display the MP4 Video -->
        <div class="video-container">
            <iframe 
                src="https://www.youtube.com/embed/XLjoVoGNnRc"
                frameborder="0" 
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
                allowfullscreen>
            </iframe>
        </div>
<div class="information" id="map_info">
<h4>Here we showed how A* Pathfinding algorithm searces the shortest distance between two cordinates/nodes on a map</h4>
<h4>Here Yellow dots are the visited nodes and at the end red line shows the shortest distance</h4>
</div>
<div class="information">
<h4>Works best on bigger screens.</h4>
</div>
</div>
<!--###################################################################################################################-->
</div>
<!--###################################################################################################################-->
        
            <div class="container" id="result">
                <div class="title">
                    Result
                </div>
                
        <div class="description">
            <p>The A* pathfinding algorithm will apply an appropriate heuristic-based search method to find the shortest path from the start node to the goal node. It will consider both the actual cost to reach a node (g) and the estimated cost to the goal (h), using the formula <strong>f = g + h</strong> to prioritize node exploration. The algorithm will return the path of nodes if a solution is found, or indicate failure (no path) if no path exists.</p>
        </div>

        <div class="key-points">
            <h3>Key Points:</h3>
            <p><strong>g</strong>: The actual cost from the start node to the current node.</p>
            <p><strong>h</strong>: The heuristic estimate from the current node to the goal.</p>
            <p><strong>f</strong>: The total estimated cost to reach the goal (sum of g and h).</p>
        </div>

        <div class="output">
            <h3>Result:</h3>
            <p>The algorithm will return the shortest path from the start node to the goal node if one exists.</p>
            <p>If no path exists, it will return failure (typically represented as <strong>null</strong> or <strong>-1</strong>).</p>
        </div>
            </div>
            <!-- Quiz Section -->
            <div class="container centered-content" id="quiz">
                <div class="title">
                    Quiz
                </div>
                <p id="question"></p>
                <div id="choices" class="choices"></div>
                <button id="next-btn" class="next-button">Next</button>
                <button id="retake-btn">Retake Quiz</button>
            </div>

            <!-- References Section -->
            <div class="container" id="references">
                <div class="title">
                    References
                </div>
                <div class="content">
                    <ul class="ref-list">
                        <li><span>Cormen, T. H., Leiserson, C. E., Rivest, R. L., Stein, C. (2022). Introduction to
                                Algorithms, Fourth Edition. United Kingdom: MIT Press.</span></li>
                        <li><span>Bhargava, A. (2016). Grokking Algorithms: An Illustrated Guide for Programmers and
                                Other Curious People. United States: Manning.</span></li>
                    </ul>
                </div>
            </div>

            <!-- Team & Tools Section -->
            <div class="container" id="tnt">
                <div class="title">
                    Team & Tools
                </div>
                <div class="content">
                    <span>Students</span>
                    <ul class="ref-list">
                        <li><a href="https://www.linkedin.com/in/adi-maqsood-90942b258/" rel="noopener"
                                target="_blank"><span>Adi Maqsood - B. Sc. (H) CS</span></a></li>
                        <li><a href="https://www.linkedin.com/in/adiz-cam" rel="noopener"
                                target="_blank"><span>Aditya Maurya - B. Sc. (H) CS</span></a></li>
                    </ul>
                    <span>Mentors</span>
                    <ul class="ref-list">
                        <li><span>Ms. Priyanka Sharma</span></li>
                    </ul>
                    <span>Tools Used</span>
                    <ul class="tools-list">
                        <li><span>Vanilla HTML, CSS, JS - for creating the web page</span></li>
                        <li><span>Figma - for designing figures and UI mockups</span></li>
                    </ul>
                </div>
            </div>



        </section>
    </div>
    <script>
        hljs.highlightAll();
        function toggleMenu() {
            const menu = document.querySelector('.nav-menu');
            menu.classList.toggle('show');
        }
    </script>
    <script src="script.js"></script>
</body>

</html>